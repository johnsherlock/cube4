<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CUBE-4 – 3D Four-in-a-Row</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; overflow: hidden; }
    body { margin: 0; background:#0f1115; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }

    /* Let OrbitControls own touch gestures on mobile */
    canvas { touch-action: none; }

    #ui {
      position: fixed; top: 12px; left: 12px; right: 12px;
      display: flex; gap: 10px; align-items: center; justify-content: space-between;
      pointer-events: none;
      z-index: 10;
    }
    #left, #right { display:flex; align-items:center; gap:10px; pointer-events: none; flex-wrap: wrap; }

    .pill {
      pointer-events: auto;
      background: rgba(20, 24, 34, 0.78);
      border: 1px solid rgba(255,255,255,0.14);
      backdrop-filter: blur(8px);
      border-radius: 999px;
      padding: 10px 14px;
      color: #fff;
      box-shadow: 0 6px 24px rgba(0,0,0,0.25);
      user-select: none;
      font-weight: 700;
      letter-spacing: 0.2px;
      line-height: 1;
    }

    button.pill { cursor: pointer; }
    button.pill:disabled { opacity: 0.45; cursor: default; }

    #statusPill { font-weight: 900; }

    #scorePill {
      opacity: 0.92;
      font-weight: 900;
      letter-spacing: 0.4px;
    }

    #undoBtn, #resetBtn {
      padding: 12px 16px;
      font-size: 14px;
      font-weight: 900;
      border: 1px solid rgba(255,255,255,0.18);
    }

    button.pill.icon {
      width: 38px;
      height: 38px;
      padding: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 1000;
      line-height: 1;
      border-radius: 999px;
    }

    #canvasWrap { width: 100vw; height: 100dvh; }
    #canvasWrap.vhfix { height: calc(var(--vh, 1vh) * 100); }

    /* Overlay container: never blocks canvas (so orbit/zoom still works) */
    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 30;
      background: transparent;
      backdrop-filter: none;
      pointer-events: none;
    }

    .card {
      pointer-events: auto;
      width: min(760px, calc(100vw - 44px));
      border-radius: 18px;
      background: rgba(16, 18, 24, 0.62);
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow: 0 18px 60px rgba(0,0,0,0.55);
      padding: 18px;
      color: #fff;
    }

    .card h1 {
      margin: 0 0 10px 0;
      font-size: 28px;
      font-weight: 1000;
      letter-spacing: 0.6px;
    }

    .card p { margin: 10px 0; opacity: 0.95; }
    .card ul { margin: 10px 0 8px 18px; padding: 0; opacity: 0.92; }
    .card li { margin: 6px 0; }
    .tiny { opacity: 0.78; font-size: 13px; }

    .actions {
      margin-top: 14px;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      flex-wrap: wrap;
    }

    /* Options form */
    .formGrid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 12px;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }

    label {
      font-weight: 900;
      opacity: 0.92;
      letter-spacing: 0.2px;
    }

    select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.18);
      color: #fff;
      outline: none;
      font-weight: 800;
      appearance: none;
    }

    option { color: #000; }

    /* Win banner (top centre, non-blocking) */
    #winBanner {
      position: fixed;
      top: 72px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 20;
      display: none;
      pointer-events: none;
    }

    #winCard {
      pointer-events: auto;
      text-align: center;
      padding: 16px 22px;
      border-radius: 16px;
      background: rgba(16, 18, 24, 0.92);
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow: 0 18px 60px rgba(0,0,0,0.45);
      backdrop-filter: blur(6px);
    }

    #winTitle {
      font-size: 30px;
      margin: 0 0 6px 0;
      font-weight: 1000;
      letter-spacing: 1px;
    }

    #winSub {
      margin: 0 0 10px 0;
      opacity: 0.85;
      font-weight: 800;
      font-size: 14px;
    }

    #winBtn {
      cursor: pointer;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: #fff;
      border-radius: 999px;
      padding: 8px 14px;
      font-weight: 1000;
      letter-spacing: 0.3px;
    }

    /* Bottom-left logo */
    #logo {
      position: fixed;
      left: 12px;
      bottom: 12px;
      z-index: 10;
      pointer-events: none;
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(20, 24, 34, 0.55);
      border: 1px solid rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.9);
      font-weight: 1000;
      letter-spacing: 1px;
      font-size: 12px;
    }

    @media (max-width: 520px) {
      #ui { top: 10px; left: 10px; right: 10px; }
      .pill { padding: 9px 12px; }
      #undoBtn, #resetBtn { padding: 10px 12px; }
      #logo { left: 10px; bottom: 10px; }
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.1/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.1/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <div id="ui">
    <div id="left">
      <div class="pill" id="statusPill">Current Player: Red</div>
      <div class="pill" id="scorePill">SCORE  Red 0 – 0 Blue</div>
    </div>
    <div id="right">
      <button class="pill" id="undoBtn" disabled>Undo</button>
      <button class="pill" id="resetBtn">Reset</button>
      <button class="pill icon" id="helpBtn" title="Rules" aria-label="Rules">?</button>
      <button class="pill icon" id="optsBtn" title="Match Options" aria-label="Match Options">⚙</button>
    </div>
  </div>

  <div id="logo">CUBE4</div>

  <!-- Welcome / Rules (shown on first load) -->
  <div id="rulesOverlay" class="overlay" aria-hidden="true">
    <div class="card" role="dialog" aria-modal="true" aria-labelledby="rulesTitle">
      <h1 id="rulesTitle">Welcome to CUBE-4</h1>
      <div class="rulesBody">
        <p><b>Goal:</b> be the first to make a line of <b>four</b> pieces in the 4×4×4 cube — in <b>any direction</b> (rows, columns, verticals, or diagonals through space).</p>
        <ul>
          <li><b>Rotate:</b> drag</li>
          <li><b>Zoom:</b> mouse wheel / trackpad • pinch on mobile</li>
          <li><b>Place:</b> click a marker (no gravity — any of the 64 spots)</li>
          <li><b>Win:</b> winning 4 are outlined in yellow</li>
        </ul>
        <p class="tiny">Tip: click a marker to focus a <b>level</b> of the cube and make placements easier.</p>
      </div>
      <div class="actions">
        <button class="pill" id="rulesPrimaryBtn">Start playing</button>
      </div>
    </div>
  </div>

  <!-- Match options -->
  <div id="optsOverlay" class="overlay" aria-hidden="true">
    <div class="card" role="dialog" aria-modal="true" aria-labelledby="optsTitle">
      <h1 id="optsTitle">Match Options</h1>

      <div class="formGrid">
        <div class="row">
          <label for="playersSel">Players</label>
          <select id="playersSel">
            <option value="one" selected>One Player</option>
            <option value="two">Two Player</option>
          </select>
        </div>

        <div class="row" id="difficultyRow">
          <label for="diffSel">Computer Difficulty</label>
          <select id="diffSel">
            <option value="easy" selected>Easy</option>
            <option value="medium">Medium</option>
            <option value="expert">Expert</option>
          </select>
        </div>

        <div class="row">
          <label for="firstSel">First Move</label>
          <select id="firstSel">
            <option value="red">Red</option>
            <option value="blue">Blue</option>
            <option value="random">Random</option>
            <option value="winner">Winner</option>
            <option value="alternate" selected>Alternate</option>
          </select>
        </div>

        <div class="row">
          <label for="matchSel">Match Style</label>
          <select id="matchSel">
            <option value="bo3" selected>Best of 3</option>
            <option value="bo5">Best of 5</option>
            <option value="unbounded">Unbounded</option>
          </select>
        </div>

        <div class="row">
          <label for="p1ColorSel">Player 1 Colour</label>
          <select id="p1ColorSel">
            <option value="red" selected>Red</option>
            <option value="blue">Blue</option>
          </select>
        </div>
      </div>

      <div class="actions">
        <button class="pill" id="optsCancelBtn">Cancel</button>
        <button class="pill" id="optsApplyBtn">Apply</button>
      </div>

      <p class="tiny">Changing <b>Players</b> or <b>Computer Difficulty</b> restarts the game and clears the scoreboard.</p>
    </div>
  </div>

  <!-- Win banner -->
  <div id="winBanner">
    <div id="winCard">
      <h1 id="winTitle">RED WINS!</h1>
      <p id="winSub">Score: Red 1 – 0 Blue</p>
      <button id="winBtn">Next game</button>
    </div>
  </div>

  <div id="canvasWrap"></div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    const SIZE = 4;
    const EMPTY = 0, P1 = 1, P2 = 2;

    // 13 unique directions for 3D 4-in-a-row
    const directions = [
      [1,0,0],[0,1,0],[0,0,1],
      [1,1,0],[1,-1,0],
      [1,0,1],[1,0,-1],
      [0,1,1],[0,1,-1],
      [1,1,1],[1,1,-1],
      [1,-1,1],[1,-1,-1],
    ];

    // ---------------------- Settings / Match State ----------------------
    const settings = {
      players: 'one',          // one | two
      difficulty: 'easy',      // easy | medium | expert
      firstMove: 'alternate',  // red | blue | random | winner | alternate
      matchStyle: 'bo3',       // bo3 | bo5 | unbounded
      p1Color: 'red',          // red | blue
    };

    const match = {
      redWins: 0,
      blueWins: 0,
      lastGameWinner: null,      // 'red' | 'blue' | null
      alternateNext: 'red',      // for alternate
      matchOver: false,
    };

    function targetWins() {
      if (settings.matchStyle === 'bo3') return 2;
      if (settings.matchStyle === 'bo5') return 3;
      return Infinity;
    }

    function p1IsRed() { return settings.p1Color === 'red'; }

    function playerForColor(color) {
      if (color === 'red') return p1IsRed() ? P1 : P2;
      return p1IsRed() ? P2 : P1;
    }

    function colorForPlayer(player) {
      if (player === P1) return p1IsRed() ? 'red' : 'blue';
      return p1IsRed() ? 'blue' : 'red';
    }

    function uiNameForPlayer(player) {
      return colorForPlayer(player) === 'red' ? 'Red' : 'Blue';
    }

    function hexForColor(color, kind) {
      if (color === 'red') {
        if (kind === 'piece') return 0xff2b2b;
        return 0xff4b4b;
      }
      if (kind === 'piece') return 0x2f7dff;
      return 0x4aa0ff;
    }

    function playerColorHex(player, kind='ui') {
      return hexForColor(colorForPlayer(player), kind);
    }

    // ---------------------- DOM ----------------------
    const wrap = document.getElementById('canvasWrap');

    const statusPill = document.getElementById('statusPill');
    const scorePill = document.getElementById('scorePill');
    const undoBtn = document.getElementById('undoBtn');
    const resetBtn = document.getElementById('resetBtn');

    const helpBtn = document.getElementById('helpBtn');
    const optsBtn = document.getElementById('optsBtn');

    const rulesOverlay = document.getElementById('rulesOverlay');
    const rulesPrimaryBtn = document.getElementById('rulesPrimaryBtn');

    const optsOverlay = document.getElementById('optsOverlay');
    const playersSel = document.getElementById('playersSel');
    const diffSel = document.getElementById('diffSel');
    const firstSel = document.getElementById('firstSel');
    const matchSel = document.getElementById('matchSel');
    const p1ColorSel = document.getElementById('p1ColorSel');
    const difficultyRow = document.getElementById('difficultyRow');
    const optsCancelBtn = document.getElementById('optsCancelBtn');
    const optsApplyBtn = document.getElementById('optsApplyBtn');

    const winBanner = document.getElementById('winBanner');
    const winTitle = document.getElementById('winTitle');
    const winSub = document.getElementById('winSub');
    const winBtn = document.getElementById('winBtn');

    function showOverlay(el) {
      el.style.display = 'flex';
      el.setAttribute('aria-hidden', 'false');
    }
    function hideOverlay(el) {
      el.style.display = 'none';
      el.setAttribute('aria-hidden', 'true');
    }

    function showRules(primaryText) {
      rulesPrimaryBtn.textContent = primaryText;
      showOverlay(rulesOverlay);
    }

    function hideRules() {
      hideOverlay(rulesOverlay);
    }

    function showOptions() {
      playersSel.value = settings.players;
      diffSel.value = settings.difficulty;
      firstSel.value = settings.firstMove;
      matchSel.value = settings.matchStyle;
      p1ColorSel.value = settings.p1Color;
      updateDifficultyVisibility();
      showOverlay(optsOverlay);
    }

    function hideOptions() {
      hideOverlay(optsOverlay);
    }

    function updateDifficultyVisibility() {
      difficultyRow.style.display = (playersSel.value === 'one') ? 'grid' : 'none';
    }

    playersSel.addEventListener('change', updateDifficultyVisibility);

    // Welcome flow
    showRules('Start playing');

    rulesPrimaryBtn.addEventListener('click', () => {
      if (rulesPrimaryBtn.textContent.trim().toLowerCase().includes('start')) {
        hideRules();
        showOptions();
      } else {
        hideRules();
      }
    });

    helpBtn.addEventListener('click', () => {
      showRules('Continue');
    });

    optsBtn.addEventListener('click', () => {
      showOptions();
    });

    optsCancelBtn.addEventListener('click', hideOptions);

    // ---------------------- Three.js Scene ----------------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0f1115);

    const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    wrap.appendChild(renderer.domElement);

    // Mobile viewport-height fix
    function setVH() {
      document.documentElement.style.setProperty('--vh', `${window.innerHeight * 0.01}px`);
      wrap.classList.add('vhfix');
    }
    window.addEventListener('resize', setVH);
    window.addEventListener('orientationchange', setVH);
    setVH();

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.target.set(0, 0, 0);

    // Touch UX (pinch zoom)
    controls.enableZoom = true;
    controls.enablePan = true;
    controls.touches = {
      ONE: THREE.TOUCH.ROTATE,
      TWO: THREE.TOUCH.DOLLY_PAN,
    };
    controls.zoomSpeed = 0.85;
    controls.rotateSpeed = 0.85;

    scene.add(new THREE.AmbientLight(0xffffff, 0.65));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(8, 10, 6);
    scene.add(dir);

    const grid = new THREE.GridHelper(16, 16, 0x2a2f3a, 0x1d2230);
    grid.position.y = -2.2;
    grid.material.opacity = 0.35;
    grid.material.transparent = true;
    scene.add(grid);

    const frameSize = SIZE - 1;
    const box = new THREE.BoxGeometry(frameSize + 1.4, frameSize + 1.4, frameSize + 1.4);
    const edges = new THREE.EdgesGeometry(box);
    const frameMat = new THREE.LineBasicMaterial({ color: 0x6f7a92, transparent: true, opacity: 0.35 });
    const frame = new THREE.LineSegments(edges, frameMat);
    scene.add(frame);

    const cellGroup = new THREE.Group();
    const pieceGroup = new THREE.Group();
    scene.add(cellGroup);
    scene.add(pieceGroup);

    // ---------------------- Board State ----------------------
    let board = makeEmptyBoard();
    let currentPlayer = playerForColor('red');
    let gameOver = false;

    // one-step undo
    let lastMove = null; // {x,y,z, player}

    // Prevent input while the computer is "thinking"
    let computerThinking = false;

    // selection / focus
    let selectedLevel = null; // z index or null

    const piecesByKey = new Map();
    const winOutlines = [];

    function keyOf(x,y,z){ return `${x},${y},${z}`; }

    function makeEmptyBoard() {
      return Array.from({ length: SIZE }, () =>
        Array.from({ length: SIZE }, () =>
          Array(SIZE).fill(EMPTY)
        )
      );
    }

    function cellToWorld(x, y, z) {
      const half = (SIZE - 1) / 2;
      // World axes: X left-right, Y up (levels), Z depth
      return new THREE.Vector3(x - half, z - half, y - half);
    }

    // Markers
    const markers = [];
    const markerGeom = new THREE.SphereGeometry(0.14, 16, 12);
    function makeMarkerMat() {
      return new THREE.MeshStandardMaterial({
        color: 0x9aa3b2,
        transparent: true,
        opacity: 0.18,
        roughness: 0.4,
        metalness: 0.0
      });
    }

    for (let x=0; x<SIZE; x++) {
      for (let y=0; y<SIZE; y++) {
        for (let z=0; z<SIZE; z++) {
          const m = new THREE.Mesh(markerGeom, makeMarkerMat());
          m.position.copy(cellToWorld(x,y,z));
          m.userData = { x, y, z, kind: 'marker' };
          cellGroup.add(m);
          markers.push(m);
        }
      }
    }

    // Raycast
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    function inBounds(x,y,z) {
      return x>=0 && y>=0 && z>=0 && x<SIZE && y<SIZE && z<SIZE;
    }

    function getWinningLineFrom(x,y,z, player) {
      for (const [dx,dy,dz] of directions) {
        let sx = x, sy = y, sz = z;
        while (true) {
          const nx = sx - dx, ny = sy - dy, nz = sz - dz;
          if (!inBounds(nx,ny,nz) || board[nx][ny][nz] !== player) break;
          sx = nx; sy = ny; sz = nz;
        }

        const line = [];
        let cx = sx, cy = sy, cz = sz;
        while (inBounds(cx,cy,cz) && board[cx][cy][cz] === player) {
          line.push([cx,cy,cz]);
          cx += dx; cy += dy; cz += dz;
        }

        if (line.length >= 4) return line.slice(0,4);
      }
      return null;
    }

    function boardIsFull() {
      for (let x=0; x<SIZE; x++)
        for (let y=0; y<SIZE; y++)
          for (let z=0; z<SIZE; z++)
            if (board[x][y][z] === EMPTY) return false;
      return true;
    }

    function clearWinOutlines() {
      for (const o of winOutlines) pieceGroup.remove(o);
      winOutlines.length = 0;
    }

    function addWinOutlineToPiece(piece) {
      const outlineGeom = new THREE.CylinderGeometry(0.39, 0.39, 0.17, 28);
      const outlineEdges = new THREE.EdgesGeometry(outlineGeom);
      const outline = new THREE.LineSegments(
        outlineEdges,
        new THREE.LineBasicMaterial({ color: 0xffd400, transparent: true, opacity: 0.95 })
      );
      outline.position.copy(piece.position);
      outline.rotation.copy(piece.rotation);
      pieceGroup.add(outline);
      winOutlines.push(outline);
    }

    function placePiece(x,y,z, player) {
      board[x][y][z] = player;
      const k = keyOf(x,y,z);

      const marker = markers.find(m => m.userData.x===x && m.userData.y===y && m.userData.z===z);
      if (marker) marker.visible = false;

      const geom = new THREE.CylinderGeometry(0.34, 0.34, 0.14, 28);
      const mat = new THREE.MeshStandardMaterial({
        color: playerColorHex(player, 'piece'),
        roughness: 0.35,
        metalness: 0.08
      });
      const piece = new THREE.Mesh(geom, mat);
      piece.position.copy(cellToWorld(x,y,z));
      piece.userData = { x, y, z, kind: 'piece', player };
      pieceGroup.add(piece);
      piecesByKey.set(k, piece);
    }

    function removePiece(x,y,z) {
      board[x][y][z] = EMPTY;
      const k = keyOf(x,y,z);
      const piece = piecesByKey.get(k);
      if (piece) {
        pieceGroup.remove(piece);
        piecesByKey.delete(k);
      }
      const marker = markers.find(m => m.userData.x===x && m.userData.y===y && m.userData.z===z);
      if (marker) marker.visible = true;
    }

    // ---------------------- Visual Focus (click to focus a level) ----------------------
    const OP_BASE = 0.18;
    const OP_OTHER_LEVELS = 0.08;
    const OP_LEVEL_MAX = 0.78;
    const OP_LEVEL_MIN = 0.48;

    function clearFocus() {
      selectedLevel = null;
      for (const m of markers) {
        if (!m.visible) continue;
        m.material.opacity = OP_BASE;
        m.material.color.setHex(0x9aa3b2);
        m.scale.setScalar(1);
      }
    }

    function applyLevelFocus(zFocus, anchor) {
      selectedLevel = zFocus;
      for (const m of markers) {
        if (!m.visible) continue;
        const u = m.userData;
        if (u.z === zFocus) {
          const dist = anchor ? (Math.abs(u.x - anchor.x) + Math.abs(u.y - anchor.y)) : 0;
          const op = Math.max(OP_LEVEL_MIN, OP_LEVEL_MAX - dist * 0.10);
          m.material.opacity = op;
        } else {
          m.material.opacity = OP_OTHER_LEVELS;
        }
        m.material.color.setHex(0x9aa3b2);
        m.scale.setScalar(1);
      }
    }

    // ---------------------- Camera Fit (desktop + mobile) ----------------------
    function fitCameraToCube() {
      const cubeHalf = (SIZE - 1) / 2;
      const padding = matchMedia('(pointer: coarse)').matches ? 4.0 : 3.0;
      const radius = Math.sqrt(3) * (cubeHalf + 0.7);
      const fov = THREE.MathUtils.degToRad(camera.fov);
      const dist = (radius / Math.sin(fov / 2)) + padding;

      const dir = new THREE.Vector3(1, 1, 1).normalize();
      camera.position.copy(dir.multiplyScalar(dist));
      controls.target.set(0,0,0);
      camera.near = 0.05;
      camera.far = dist * 6;
      camera.updateProjectionMatrix();
      controls.update();
    }

    // ---------------------- UI Updates ----------------------
    function updateStatusPill() {
      const colorName = uiNameForPlayer(currentPlayer);

      if (settings.players === 'one') {
        // One-player mode: label human vs CPU clearly
        if (currentPlayer === P1) {
          statusPill.textContent = `Player 1: ${colorName}`;
        } else {
          statusPill.textContent = `CPU: ${colorName}`;
        }
      } else {
        // Two-player mode
        statusPill.textContent = `Current Player: ${colorName}`;
      }

      statusPill.style.background = `rgba(20, 24, 34, 0.78)`;
      statusPill.style.borderColor = `rgba(255,255,255,0.14)`;
      statusPill.style.boxShadow = '0 6px 24px rgba(0,0,0,0.25)';
      statusPill.style.color = '#fff';
      statusPill.style.outline = `2px solid ${colorName === 'Red' ? '#ff4b4b' : '#4aa0ff'}`;
      statusPill.style.outlineOffset = '0px';

      // Also tint the cube frame
      frameMat.color.setHex(playerColorHex(currentPlayer, 'ui'));
    }

    function updateScorePill() {
      scorePill.textContent = `SCORE  Red ${match.redWins} – ${match.blueWins} Blue`;
    }

    function showWinBanner(title, titleColorHex, subtitle, buttonText) {
      winTitle.textContent = title;
      winTitle.style.color = `#${titleColorHex.toString(16).padStart(6,'0')}`;
      winSub.textContent = subtitle;
      winBtn.textContent = buttonText;
      winBanner.style.display = 'block';
    }

    function hideWinBanner() {
      winBanner.style.display = 'none';
    }

    function endMatchIfNeeded() {
      const t = targetWins();
      if (match.redWins >= t || match.blueWins >= t) {
        match.matchOver = true;
      }
    }

    // ---------------------- Game Flow ----------------------
    function chooseStartingColorForNextGame() {
      if (settings.firstMove === 'red') return 'red';
      if (settings.firstMove === 'blue') return 'blue';
      if (settings.firstMove === 'random') return (Math.random() < 0.5 ? 'red' : 'blue');
      if (settings.firstMove === 'winner') {
        return match.lastGameWinner ?? (Math.random() < 0.5 ? 'red' : 'blue');
      }
      const c = match.alternateNext;
      match.alternateNext = (match.alternateNext === 'red') ? 'blue' : 'red';
      return c;
    }

    function resetBoardOnly() {
      board = makeEmptyBoard();
      gameOver = false;
      lastMove = null;
      undoBtn.disabled = true;
      clearWinOutlines();

      while (pieceGroup.children.length) pieceGroup.remove(pieceGroup.children[0]);
      piecesByKey.clear();

      for (const m of markers) {
        m.visible = true;
        m.material.opacity = OP_BASE;
        m.material.color.setHex(0x9aa3b2);
        m.scale.setScalar(1);
      }

      clearFocus();
      hideWinBanner();
    }

    function updateUndoVisibility() {
      if (settings.players === 'one') {
        // No undo in one-player mode (prevents undoing the computer's move)
        undoBtn.style.display = 'none';
        lastMove = null;
        undoBtn.disabled = true;
      } else {
        undoBtn.style.display = '';
        undoBtn.disabled = !lastMove;
      }
    }

    function startNewGame(keepScore=true) {
      if (!keepScore) {
        match.redWins = 0;
        match.blueWins = 0;
        match.lastGameWinner = null;
        match.alternateNext = 'red';
        match.matchOver = false;
      }

      resetBoardOnly();

      // ensure UI + state consistent with player mode
      updateUndoVisibility();
      computerThinking = false;

      const startColor = chooseStartingColorForNextGame();
      currentPlayer = playerForColor(startColor);

      updateStatusPill();
      updateScorePill();

      maybeComputerTurn();
    }

    function resetEverything() {
      startNewGame(false);
    }

    function undoOnce() {
      if (settings.players === 'one') return; // safety: hidden anyway
      if (!lastMove) return;
      if (gameOver) {
        gameOver = false;
        hideWinBanner();
      }

      clearWinOutlines();
      removePiece(lastMove.x, lastMove.y, lastMove.z);

      currentPlayer = lastMove.player;
      lastMove = null;
      undoBtn.disabled = true;

      updateStatusPill();
      if (selectedLevel !== null) applyLevelFocus(selectedLevel, null);
    }

    undoBtn.addEventListener('click', undoOnce);
    resetBtn.addEventListener('click', resetEverything);

    winBtn.addEventListener('click', () => {
      if (match.matchOver) startNewGame(false);
      else startNewGame(true);
    });

    // Apply options
    optsApplyBtn.addEventListener('click', () => {
      const prevPlayers = settings.players;
      const prevDiff = settings.difficulty;

      settings.players = playersSel.value;
      settings.difficulty = diffSel.value;
      settings.firstMove = firstSel.value;
      settings.matchStyle = matchSel.value;
      settings.p1Color = p1ColorSel.value;

      hideOptions();

      const wipe = (prevPlayers !== settings.players) || (prevDiff !== settings.difficulty);
      startNewGame(!wipe);

      fitCameraToCube();
    });

    // ---------------------- Input ----------------------
    function setPointerFromEvent(ev) {
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -(((ev.clientY - rect.top) / rect.height) * 2 - 1);
    }

    function pickVisibleMarker(ev) {
      setPointerFromEvent(ev);
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(cellGroup.children, false);
      const hit = hits.find(h => h.object.visible);
      return hit ? hit.object : null;
    }

    const isCoarsePointer = matchMedia('(pointer: coarse)').matches;

    function handleOutsideClick(ev) {
      if (!isCoarsePointer) return;
      const m = pickVisibleMarker(ev);
      if (!m) clearFocus();
    }

    document.addEventListener('pointerup', handleOutsideClick);

    // Safe click gating
    let downPos = null;
    let downTime = 0;

    const CLICK_MOVE_TOL = isCoarsePointer ? 14 : 6;
    const CLICK_TIME_TOL = isCoarsePointer ? 800 : 650;

    renderer.domElement.addEventListener('pointerdown', (ev) => {
      downPos = { x: ev.clientX, y: ev.clientY };
      downTime = performance.now();
    });

    renderer.domElement.addEventListener('pointerup', (ev) => {
      if (!downPos) return;
      const dx = ev.clientX - downPos.x;
      const dy = ev.clientY - downPos.y;
      const dist = Math.hypot(dx, dy);
      const dt = performance.now() - downTime;
      downPos = null;

      if (dist > CLICK_MOVE_TOL) return;
      if (dt > CLICK_TIME_TOL) return;

      if (computerThinking) return; // disable row selection while computer is moving
      if (gameOver || match.matchOver) return;
      if (optsOverlay.style.display === 'flex') return;

      const m = pickVisibleMarker(ev);
      if (!m) {
        if (!isCoarsePointer) clearFocus();
        return;
      }

      const { x, y, z } = m.userData;

      // First click: focus level
      if (selectedLevel === null) {
        applyLevelFocus(z, { x, y });
        return;
      }

      // If clicked another level before placing -> switch focus
      if (z !== selectedLevel) {
        applyLevelFocus(z, { x, y });
        return;
      }

      // Second click in focused level: attempt place
      if (board[x][y][z] !== EMPTY) return;

      // Block human placing when it's computer's turn
      if (settings.players === 'one' && isComputerTurn()) return;

      doMove(x,y,z, currentPlayer);
    });

    // Desktop: Esc deselects focus
    window.addEventListener('keydown', (ev) => {
      if (ev.key === 'Escape') {
        if (!isCoarsePointer) clearFocus();
      }
    });

    // ---------------------- Move resolution ----------------------
    function isComputerTurn() {
      if (settings.players !== 'one') return false;
      return currentPlayer === P2;
    }

    function doMove(x,y,z, player) {
      placePiece(x,y,z, player);

      // Successful placement deselects the focused level
      clearFocus();

      // Track last move ONLY for two-player undo
      if (settings.players === 'two') {
        lastMove = { x, y, z, player };
        undoBtn.disabled = false;
      } else {
        lastMove = null;
        undoBtn.disabled = true;
      }

      const winning4 = getWinningLineFrom(x,y,z, player);
      if (winning4) {
        clearWinOutlines();
        for (const [wx,wy,wz] of winning4) {
          const piece = piecesByKey.get(keyOf(wx,wy,wz));
          if (piece) addWinOutlineToPiece(piece);
        }

        const winnerColor = colorForPlayer(player);
        match.lastGameWinner = winnerColor;
        if (winnerColor === 'red') match.redWins++; else match.blueWins++;
        updateScorePill();

        endMatchIfNeeded();

        const title = match.matchOver ? `${winnerColor.toUpperCase()} WINS THE MATCH!` : `${winnerColor.toUpperCase()} WINS!`;
        const sub = match.matchOver
          ? `Final Score: Red ${match.redWins} – ${match.blueWins} Blue`
          : `Score: Red ${match.redWins} – ${match.blueWins} Blue`;

        showWinBanner(title, hexForColor(winnerColor, 'ui'), sub, match.matchOver ? 'New match' : 'Next game');
        gameOver = true;
        frameMat.color.setHex(hexForColor(winnerColor, 'ui'));
        return;
      }

      if (boardIsFull()) {
        match.lastGameWinner = null;
        const title = `DRAW!`;
        const sub = `Score: Red ${match.redWins} – ${match.blueWins} Blue`;
        showWinBanner(title, 0xffffff, sub, 'Next game');
        gameOver = true;
        return;
      }

      currentPlayer = (currentPlayer === P1) ? P2 : P1;
      updateStatusPill();

      maybeComputerTurn();
    }

    // ---------------------- Computer Player ----------------------
    function allLegalMoves() {
      const moves = [];
      for (let x=0; x<SIZE; x++)
        for (let y=0; y<SIZE; y++)
          for (let z=0; z<SIZE; z++)
            if (board[x][y][z] === EMPTY) moves.push([x,y,z]);
      return moves;
    }

    function wouldWinMove(x,y,z, player) {
      board[x][y][z] = player;
      const w = getWinningLineFrom(x,y,z, player);
      board[x][y][z] = EMPTY;
      return !!w;
    }

    function chooseComputerMove() {
      const legal = allLegalMoves();
      if (legal.length === 0) return null;

      if (settings.difficulty === 'easy') {
        return legal[Math.floor(Math.random()*legal.length)];
      }

      if (settings.difficulty === 'medium') {
        for (const [x,y,z] of legal) if (wouldWinMove(x,y,z,P2)) return [x,y,z];
        for (const [x,y,z] of legal) if (wouldWinMove(x,y,z,P1)) return [x,y,z];
        return legal[Math.floor(Math.random()*legal.length)];
      }

      for (const [x,y,z] of legal) if (wouldWinMove(x,y,z,P2)) return [x,y,z];
      for (const [x,y,z] of legal) if (wouldWinMove(x,y,z,P1)) return [x,y,z];

      function scoreFor(player) {
        let score = 0;
        for (let x=0; x<SIZE; x++) {
          for (let y=0; y<SIZE; y++) {
            for (let z=0; z<SIZE; z++) {
              for (const [dx,dy,dz] of directions) {
                const ex = x + dx*3, ey = y + dy*3, ez = z + dz*3;
                if (!inBounds(ex,ey,ez)) continue;
                let ok = true;
                let count = 0;
                for (let i=0; i<4; i++) {
                  const cx = x + dx*i, cy = y + dy*i, cz = z + dz*i;
                  const v = board[cx][cy][cz];
                  if (v !== EMPTY && v !== player) { ok = false; break; }
                  if (v === player) count++;
                }
                if (!ok) continue;
                score += (count === 0 ? 1 : (count*count*3));
              }
            }
          }
        }
        return score;
      }

      let best = legal[0];
      let bestScore = -Infinity;

      for (const [x,y,z] of legal) {
        board[x][y][z] = P2;
        const s2 = scoreFor(P2);
        const s1 = scoreFor(P1);
        board[x][y][z] = EMPTY;

        const jitter = (Math.random() - 0.5) * 6;
        const s = (s2 - 0.85*s1) + jitter;

        if (s > bestScore) {
          bestScore = s;
          best = [x,y,z];
        }
      }

      if (Math.random() < 0.18) {
        return legal[Math.floor(Math.random()*legal.length)];
      }

      return best;
    }

    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    async function maybeComputerTurn() {
      if (!isComputerTurn()) return;
      if (gameOver || match.matchOver) return;

      computerThinking = true;
      try {
        // simulate thinking: random 1–3 seconds
        await sleep(1000 + Math.random()*2000);

        // if human changed state during delay
        if (!isComputerTurn() || gameOver || match.matchOver) return;

        const move = chooseComputerMove();
        if (!move) return;
        const [x,y,z] = move;

        // Computer places directly (no focus requirement)
        doMove(x,y,z, P2);
      } finally {
        computerThinking = false;
      }
    }

    // ---------------------- Resize / Render ----------------------
    function resize() {
      const w = wrap.clientWidth;
      const h = wrap.clientHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', () => { resize(); fitCameraToCube(); });

    function tick() {
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }

    // ---------------------- Self-tests ----------------------
    function assert(cond, msg) {
      if (!cond) throw new Error(`Self-test failed: ${msg}`);
    }

    function runSelfTests() {
      board = makeEmptyBoard();
      for (let i=0; i<4; i++) board[i][i][i] = P1;
      const w1 = getWinningLineFrom(1,1,1,P1);
      assert(Array.isArray(w1) && w1.length === 4, 'XYZ diagonal win not detected');

      board = makeEmptyBoard();
      for (let x=0; x<4; x++) board[x][0][0] = P2;
      const w2 = getWinningLineFrom(2,0,0,P2);
      assert(Array.isArray(w2) && w2.length === 4, 'X-axis win not detected');

      board = makeEmptyBoard();
      for (let z=0; z<4; z++) board[0][0][z] = P1;
      const w3 = getWinningLineFrom(0,0,2,P1);
      assert(Array.isArray(w3) && w3.length === 4, 'Z-axis win not detected');

      board = makeEmptyBoard();
      board[0][0][0] = P1;
      board[1][1][0] = P1;
      board[2][2][1] = P1;
      board[3][3][2] = P1;
      const w4 = getWinningLineFrom(3,3,2,P1);
      assert(w4 === null, 'False positive win detected');

      // New: best-of targets
      settings.matchStyle = 'bo3';
      assert(targetWins() === 2, 'bo3 target should be 2');
      settings.matchStyle = 'bo5';
      assert(targetWins() === 3, 'bo5 target should be 3');
      settings.matchStyle = 'unbounded';
      assert(targetWins() === Infinity, 'unbounded target should be Infinity');

      settings.matchStyle = 'bo3';
      board = makeEmptyBoard();
    }

    runSelfTests();

    // Init
    resize();
    fitCameraToCube();
    updateScorePill();
    updateUndoVisibility();
    startNewGame(false);
    tick();
  </script>
</body>
</html>
